<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Clases - Inteligencia Artificial</title>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Roboto', sans-serif;
            background-color: #f4f4f4;
            margin: 0;
            padding: 20px;
        }
        header {
            background-color: #f2c041;
            color: white;
            padding: 10px 20px;
            text-align: center;
            border-radius: 5px;
            margin-bottom: 20px;
        }
        .container {
            max-width: 800px; /* Ancho máximo para el contenido */
            margin: 0 auto; /* Centramos el contenedor */
        }
        h2 {
            color: #333;
            margin-top: 20px;
        }
        p {
            line-height: 1.6;
            color: #555;
            margin-bottom: 20px;
            text-align: justify;
            padding: 10px; /* Añadido padding para los párrafos */
            background-color: #ffffff; /* Fondo blanco para destacar el texto */
            border-radius: 5px; /* Bordes redondeados para los párrafos */
            box-shadow: 0 1px 5px rgba(0, 0, 0, 0.1); /* Sombra suave */
        }
        section {
            margin-bottom: 30px; /* Espaciado entre secciones */
            padding: 20px; /* Padding para las secciones */
            background-color: #ffffff; /* Fondo blanco para las secciones */
            border-radius: 5px; /* Bordes redondeados para las secciones */
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1); /* Sombra para las secciones */
        }
        table {
            width: 100%; /* La tabla ocupa todo el ancho del contenedor */
            margin: 20px auto;
            border-collapse: collapse;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            border-radius: 5px;
            overflow: hidden;
        }
        th, td {
            border: 1px solid #dddddd;
            text-align: left;
            padding: 12px;
        }
        th {
            background-color: #4CAF50; /* Color verde para el encabezado */
            color: white;
        }
        tr:nth-child(even) {
            background-color: #f2f2f2; /* Color claro para filas pares */
        }
        tr:hover {
            background-color: #d1ffd1; /* Color al pasar el mouse */
        }
        pre {
            background-color: #f8f8f8; /* Fondo claro para el código */
            padding: 15px; /* Espacio interno */
            border-radius: 5px; /* Bordes redondeados */
            overflow-x: auto; /* Permite el desplazamiento horizontal */
        }
    </style>
</head>
<body>

<header>
    <h1>Clases de Inteligencia Artificial</h1>
</header>

<div class="container">
    <section>
        <h2>22/08/2024</h2>
        <p>
            En la primera clase vimos definiciones de Inteligencia Artificial, conceptos, objetivos, lógica,
            se explicó el método de Alan Turing, problemas de búsqueda, métodos de búsqueda y hicimos práctica con Git.
        </p>
    </section>

    <section>
        <h2>29/08/2024 - Video:</h2>
        <p>
            Explica cómo las redes neuronales imitan el cerebro humano para reconocer patrones en imágenes. 
            Muestra la estructura básica de una red neuronal, como las capas de entrada, ocultas y de salida. 
            Las capas de entrada procesan los píxeles, las ocultas identifican patrones, y la de salida clasifica los dígitos. 
            La función sigmoide normaliza las activaciones entre 0 y 1, ayudando en el reconocimiento preciso. 
            También se menciona la importancia de ajustar los pesos y sesgos para optimizar el rendimiento de la red.
        </p>
    </section>

    <section>
        <h2>12/09/2024 - Clase:</h2>
        <p>
            En la clase se realizó la práctica en Google Colab donde trabajamos un ejercicio en el que utilizamos 
            una herramienta llamada TensorFlow para crear un modelo que convierte temperaturas de Celsius a Fahrenheit. 
            Primero, tenemos dos listas de datos: una con valores en grados Celsius y otra con sus equivalentes en Fahrenheit. 
            Luego, se construye un modelo sencillo con capas que aprenden a hacer esa conversión. 
            El modelo se entrena usando un proceso automático, donde va mejorando su precisión con cada ciclo, o "época". 
            Después del entrenamiento, el modelo puede hacer predicciones, como convertir 100 grados Celsius a Fahrenheit. 
            Al final, también se muestra cómo se ven las conexiones internas del modelo, lo que nos permite ver qué aprendió.
        </p>
    </section>

<section>
        <h2>10/10/2024 - Clase:</h2>
        <p>
            Mis intereses según el perfil de O*NET se orientan principalmente hacia áreas convencionales, 
            empresariales e investigativas. Me atraen los trabajos que siguen procedimientos claros y rutinas organizadas, 
            donde puedo manejar información y prestar atención a los detalles de manera estructurada. También me interesan los proyectos 
            empresariales que implican tomar decisiones y asumir riesgos para lograr objetivos. Además, disfruto resolver problemas y buscar i
            nformación a través de la investigación. Aunque tengo algunos intereses en los campos artístico, social y realista, mi preferencia 
            es por actividades más organizadas y estructuradas, que me permitan seguir reglas y trabajar de manera eficiente.
        </p>
    </section>
    

    <h2 style="text-align:center;">Resultados de Búsqueda de Laberintos</h2>

    <table>
        <tr>
            <th>Método</th>
            <th>Grupo</th>
            <th>Estados Explorados</th>
        </tr>
        <tr>
            <td>DFS</td>
            <td>Grupo A</td>
            <td>227</td>
        </tr>
        <tr>
            <td>DFS</td>
            <td>Grupo B</td>
            <td>265</td>
        </tr>
        <tr>
            <td>BFS</td>
            <td>Grupo A</td>
            <td>331</td>
        </tr>
        <tr>
            <td>BFS</td>
            <td>Grupo B</td>
            <td>319</td>
        </tr>
    </table>

    <section>
        <h2>Código de TensorFlow para Conversión de Temperatura</h2>
        <pre>
            <code>
# Importamos las librerías necesarias
import tensorflow as tf
import numpy as np

# Definimos los datos de entrada (Celsius) y los datos de salida (Fahrenheit)
celsius = np.array([-40, -10, 0, 8, 15, 22, 38], dtype=float)
fahrenheit = np.array([-40, 14, 32, 46, 59, 72, 100], dtype=float)

# Definimos las capas de la red neuronal
# capa = tf.keras.layers.Dense(units=1, input_shape=[1])  # Capa de salida simple (comentada)
oculta1 = tf.keras.layers.Dense(units=3, input_shape=[1]) # Primera capa oculta con 3 neuronas
oculta2 = tf.keras.layers.Dense(units=3)                   # Segunda capa oculta con 3 neuronas
salida = tf.keras.layers.Dense(units=1)                    # Capa de salida con 1 neurona

# Creamos el modelo secuencial con las capas definidas
modelo = tf.keras.Sequential([oculta1, oculta2, salida])

# Compilamos el modelo especificando el optimizador y la función de pérdida
modelo.compile(
    optimizer=tf.keras.optimizers.Adam(0.1),   # Optimizador Adam con tasa de aprendizaje de 0.1
    loss='mean_squared_error'                    # Función de pérdida: error cuadrático medio
)

# Comenzamos el entrenamiento
print("Comenzando entrenamiento...")
historial = modelo.fit(celsius, fahrenheit, epochs=1000, verbose=False) # Entrenamos el modelo durante 1000 épocas
print("Modelo entrenado!")

# Importamos Matplotlib para graficar la pérdida durante el entrenamiento
import matplotlib.pyplot as plt
plt.xlabel("# Época")                              # Etiqueta para el eje X
plt.ylabel("Magnitud de pérdida")                  # Etiqueta para el eje Y
plt.plot(historial.history["loss"])                # Graficamos la pérdida

# Hacemos una predicción
print("Hagamos una predicción!")
resultado = modelo.predict([100.0])                # Realizamos una predicción para 100 grados Celsius
print("El resultado es " + str(resultado) + " fahrenheit!")

# Mostramos las variables internas del modelo
print("Variables internas del modelo")
#print(capa.get_weights())                          # Mostramos los pesos de la capa (comentado)
print(oculta1.get_weights())                        # Pesos de la primera capa oculta
print(oculta2.get_weights())                        # Pesos de la segunda capa oculta
print(salida.get_weights())                         # Pesos de la capa de salida
            </code>
        </pre>
    </section>

<section>
        <h2>Punto 5 Parcial, Codigo logic.py</h2>
        <pre>
            <code>
import itertools

# Clase base para representar una oración lógica
class Sentence():
    def evaluate(self, model):
        """Evaluates the logical sentence."""
        raise Exception("nothing to evaluate")  # Método que debe ser implementado por subclases

    def formula(self):
        """Returns string formula representing logical sentence."""
        return ""  # Método que debe ser implementado por subclases

    def symbols(self):
        """Returns a set of all symbols in the logical sentence."""
        return set()  # Método que debe ser implementado por subclases

    @classmethod
    def validate(cls, sentence):
        """Validates that the provided object is a Sentence."""
        if not isinstance(sentence, Sentence):
            raise TypeError("must be a logical sentence")  # Lanza un error si no es una oración lógica

    @classmethod
    def parenthesize(cls, s):
        """Parenthesizes an expression if not already parenthesized."""
        def balanced(s):
            """Checks if a string has balanced parentheses."""
            count = 0
            for c in s:
                if c == "(":
                    count += 1
                elif c == ")":
                    if count <= 0:
                        return False  # Desbalanceado si se encuentra un ')' sin '(' correspondiente
                    count -= 1
            return count == 0  # Retorna True si todas las paréntesis están balanceadas

        # Comprueba si ya está parentizado
        if not len(s) or s.isalpha() or (
            s[0] == "(" and s[-1] == ")" and balanced(s[1:-1])
        ):
            return s
        else:
            return f"({s})"  # Agrega paréntesis si es necesario

# Clase que representa un símbolo lógico (por ejemplo, una variable)
class Symbol(Sentence):
    def __init__(self, name):
        self.name = name  # Nombre del símbolo

    def __eq__(self, other):
        return isinstance(other, Symbol) and self.name == other.name  # Comparación de igualdad

    def __hash__(self):
        return hash(("symbol", self.name))  # Permite que los símbolos sean utilizados en conjuntos

    def __repr__(self):
        return self.name  # Representación en cadena del símbolo

    def evaluate(self, model):
        """Evaluates the symbol in the given model."""
        try:
            return bool(model[self.name])  # Retorna el valor del símbolo en el modelo
        except KeyError:
            raise EvaluationException(f"variable {self.name} not in model")  # Error si el símbolo no está en el modelo

    def formula(self):
        return self.name  # Retorna el nombre del símbolo como su fórmula

    def symbols(self):
        return {self.name}  # Retorna un conjunto con el símbolo

# Clase que representa la negación lógica
class Not(Sentence):
    def __init__(self, operand):
        Sentence.validate(operand)  # Valida que el operando sea una oración lógica
        self.operand = operand

    def __eq__(self, other):
        return isinstance(other, Not) and self.operand == other.operand  # Comparación de igualdad

    def __hash__(self):
        return hash(("not", hash(self.operand)))  # Permite que las negaciones sean utilizadas en conjuntos

    def __repr__(self):
        return f"Not({self.operand})"  # Representación en cadena de la negación

    def evaluate(self, model):
        return not self.operand.evaluate(model)  # Evalúa la negación del operando

    def formula(self):
        return "¬" + Sentence.parenthesize(self.operand.formula())  # Retorna la fórmula de la negación

    def symbols(self):
        return self.operand.symbols()  # Retorna los símbolos del operando

# Clase que representa la conjunción lógica (AND)
class And(Sentence):
    def __init__(self, *conjuncts):
        for conjunct in conjuncts:
            Sentence.validate(conjunct)  # Valida cada conjuncto
        self.conjuncts = list(conjuncts)

    def __eq__(self, other):
        return isinstance(other, And) and self.conjuncts == other.conjuncts  # Comparación de igualdad

    def __hash__(self):
        return hash(
            ("and", tuple(hash(conjunct) for conjunct in self.conjuncts))  # Permite que las conjunciones sean utilizadas en conjuntos
        )

    def __repr__(self):
        conjunctions = ", ".join(
            [str(conjunct) for conjunct in self.conjuncts]  # Representación en cadena de la conjunción
        )
        return f"And({conjunctions})"

    def add(self, conjunct):
        Sentence.validate(conjunct)  # Valida el nuevo conjuncto
        self.conjuncts.append(conjunct)  # Agrega el conjuncto a la lista

    def evaluate(self, model):
        return all(conjunct.evaluate(model) for conjunct in self.conjuncts)  # Evalúa la conjunción

    def formula(self):
        if len(self.conjuncts) == 1:
            return self.conjuncts[0].formula()  # Si hay solo un conjuncto, retorna su fórmula
        return " ∧ ".join([Sentence.parenthesize(conjunct.formula())
                           for conjunct in self.conjuncts])  # Retorna la fórmula de la conjunción

    def symbols(self):
        return set.union(*[conjunct.symbols() for conjunct in self.conjuncts])  # Retorna la unión de todos los símbolos

# Clase que representa la disyunción lógica (OR)
class Or(Sentence):
    def __init__(self, *disjuncts):
        for disjunct in disjuncts:
            Sentence.validate(disjunct)  # Valida cada disyunto
        self.disjuncts = list(disjuncts)

    def __eq__(self, other):
        return isinstance(other, Or) and self.disjuncts == other.disjuncts  # Comparación de igualdad

    def __hash__(self):
        return hash(
            ("or", tuple(hash(disjunct) for disjunct in self.disjuncts))  # Permite que las disyunciones sean utilizadas en conjuntos
        )

    def __repr__(self):
        disjuncts = ", ".join([str(disjunct) for disjunct in self.disjuncts])  # Representación en cadena de la disyunción
        return f"Or({disjuncts})"

    def evaluate(self, model):
        return any(disjunct.evaluate(model) for disjunct in self.disjuncts)  # Evalúa la disyunción

    def formula(self):
        if len(self.disjuncts) == 1:
            return self.disjuncts[0].formula()  # Si hay solo un disyunto, retorna su fórmula
        return " ∨  ".join([Sentence.parenthesize(disjunct.formula())
                            for disjunct in self.disjuncts])  # Retorna la fórmula de la disyunción

    def symbols(self):
        return set.union(*[disjunct.symbols() for disjunct in self.disjuncts])  # Retorna la unión de todos los símbolos

# Clase que representa la implicación lógica
class Implication(Sentence):
    def __init__(self, antecedent, consequent):
        Sentence.validate(antecedent)  # Valida el antecedente
        Sentence.validate(consequent)  # Valida el consecuente
        self.antecedent = antecedent
        self.consequent = consequent

    def __eq__(self, other):
        return (isinstance(other, Implication)
                and self.antecedent == other.antecedent
                and self.consequent == other.consequent)  # Comparación de igualdad

    def __hash__(self):
        return hash(("implies", hash(self.antecedent), hash(self.consequent)))  # Permite que las implicaciones sean utilizadas en conjuntos

    def __repr__(self):
        return f"Implication({self.antecedent}, {self.consequent})"  # Representación en cadena de la implicación

    def evaluate(self, model):
        return ((not self.antecedent.evaluate(model))
                or self.consequent.evaluate(model))  # Evalúa la implicación

    def formula(self):
        antecedent = Sentence.parenthesize(self.antecedent.formula())
        consequent = Sentence.parenthesize(self.consequent.formula())
        return f"{antecedent} => {consequent}"  # Retorna la fórmula de la implicación

    def symbols(self):
        return set.union(self.antecedent.symbols(), self.consequent.symbols())  # Retorna la unión de los símbolos

# Clase que representa la bicondicional lógica
class Biconditional(Sentence):
    def __init__(self, left, right):
        Sentence.validate(left)  # Valida el lado izquierdo
        Sentence.validate(right)  # Valida el lado derecho
        self.left = left
        self.right = right

    def __eq__(self, other):
        return (isinstance(other, Biconditional)
                and self.left == other.left
                and self.right == other.right)  # Comparación de igualdad

    def __hash__(self):
        return hash(("biconditional", hash(self.left), hash(self.right)))  # Permite que las bicondicionales sean utilizadas en conjuntos

    def __repr__(self):
        return f"Biconditional({self.left}, {self.right})"  # Representación en cadena de la bicondicional

    def evaluate(self, model):
        return ((self.left.evaluate(model)
                 and self.right.evaluate(model))
                or (not self.left.evaluate(model)
                    and not self.right.evaluate(model)))  # Evalúa la bicondicional

    def formula(self):
        left = Sentence.parenthesize(str(self.left))
        right = Sentence.parenthesize(str(self.right))
        return f"{left} <=> {right}"  # Retorna la fórmula de la bicondicional

    def symbols(self):
        return set.union(self.left.symbols(), self.right.symbols())  # Retorna la unión de los símbolos

def model_check(knowledge, query):
    """Checks if knowledge base entails query."""
    def check_all(knowledge, query, symbols, model):
        """Checks if knowledge base entails query, given a particular model."""
        # If model has an assignment for each symbol
        if not symbols:
            # If knowledge base is true in model, then query must also be true
            if knowledge.evaluate(model):
                return query.evaluate(model)  # Verifica que la consulta sea verdadera
            return True  # Si no hay símbolos restantes, considera que no se necesita más verificación
        else:
            # Choose one of the remaining unused symbols
            remaining = symbols.copy()
            p = remaining.pop()  # Escoge un símbolo no utilizado

            # Create a model where the symbol is true
            model_true = model.copy()
            model_true[p] = True

            # Create a model where the symbol is false
            model_false = model.copy()
            model_false[p] = False

            # Ensure entailment holds in both models
            return (check_all(knowledge, query, remaining, model_true) and
                    check_all(knowledge, query, remaining, model_false))  # Comprueba la validez en ambos modelos

    # Get all symbols in both knowledge and query
    symbols = set.union(knowledge.symbols(), query.symbols())  # Obtiene todos los símbolos

    # Check that knowledge entails query
    return check_all(knowledge, query, symbols, dict())  # Comienza la verificación de la consulta

            </code>
        </pre>
    </section>

    <section>
        <h2>Parcial Punto 6, Codigo estudianteunimayor.py</h2>
        <pre>
            <code>
from logic import *

lluvia = Symbol("lluvia")
bbc = Symbol("bbc")
unimayor = Symbol("unimayor")
estudiantes = Symbol("estudiantes")

conocimiento = And(
    Implication(Not(lluvia), bbc), 
    Or(bbc, unimayor),              
    Not(And(bbc, unimayor)),        
    unimayor                         
)
print(model_check(conocimiento, lluvia))
print(model_check(conocimiento, bbc))

            </code>
        </pre>
    </section>

<section>
    <h2>Reto: Caballeros</h2>
    <p>
        Este ejercicio consiste en resolver acertijos lógicos de "Caballeros y Truhanes". En estos acertijos, cada personaje es un caballero (que siempre dice la verdad) o un truhán (que siempre miente). El objetivo es determinar si cada personaje es un caballero o un truhán, basado en las frases que dicen.
    </p>
    <p>
        El ejercicio requiere agregar conocimiento lógico a diferentes bases de conocimiento (conocimiento0, conocimiento1, conocimiento2 y conocimiento3) para resolver cuatro acertijos. Para cada acertijo, se debe formular la información lógica adecuada y luego utilizar una función de comprobación de modelos para deducir la verdad.
    </p>
    <p>
        Se proporciona un archivo <code>logic.py</code> con clases para conectivas lógicas y una función <code>model_check</code> para evaluar los modelos posibles, y un archivo <code>puzzle.py</code> con símbolos proposicionales y bases de conocimiento vacías. El reto consiste en completar estas bases de conocimiento para resolver los acertijos, utilizando lógica proposicional para representar las frases de los personajes.
    </p>
    <p>
        Los acertijos incluyen situaciones con diferentes números de personajes y sus respectivas frases, y la solución debe ser obtenida sin modificar el archivo <code>logic.py</code>. Es crucial que las soluciones sean correctas para aprobar el ejercicio.
    </p>
    <h3>Acertijos:</h3>
    <ul>
        <li><strong>Puzzle 0:</strong> Un solo personaje, A, dice "Soy a la vez un caballero y un bribón".</li>
        <li><strong>Puzzle 1:</strong> Dos personajes, A y B. A dice "Los dos somos truhanes", y B no dice nada.</li>
        <li><strong>Puzzle 2:</strong> Dos personajes, A y B. A dice "Somos de la misma clase", y B dice "Somos de distinta clase".</li>
        <li><strong>Puzzle 3:</strong> Tres personajes, A, B y C. A dice "Soy un caballero o soy un bribón", B dice "A dijo ‘Soy un bribón’" y "C es un bribón", y C dice "A es un caballero".</li>
    </ul>
    <p>
        La tarea es representar las frases lógicamente y permitir que un algoritmo resuelva los acertijos.
    </p>
</section>

        <h2>Puzzle.py</h2>
        <pre>
            <code>
# Se importa todo desde el módulo 'logic', que probablemente contiene funciones y clases necesarias
# para resolver los rompecabezas de lógica basados en el comportamiento de caballeros y villanos.

# Definimos las proposiciones lógicas para A, B y C, indicando si son caballeros (Knight) o villanos (Knave).
AKnight = Symbol("A is a Knight")  # A es un caballero
AKnave = Symbol("A is a Knave")    # A es un villano

BKnight = Symbol("B is a Knight")  # B es un caballero
BKnave = Symbol("B is a Knave")    # B es un villano

CKnight = Symbol("C is a Knight")  # C es un caballero
CKnave = Symbol("C is a Knave")    # C es un villano

# Puzzle 0: A dice "Soy tanto un caballero como un villano".
# El conocimiento aquí debería reflejar lo que se puede deducir de esa afirmación.
knowledge0 = And(
    # TODO: Definir las condiciones que corresponden a este rompecabezas
)

# Puzzle 1: A dice "Somos ambos villanos". B no dice nada.
# El conocimiento aquí debería reflejar las implicaciones de la afirmación de A.
knowledge1 = And(
    # TODO: Definir las condiciones que corresponden a este rompecabezas
)

# Puzzle 2: A dice "Somos del mismo tipo". B dice "Somos de tipos diferentes".
# Aquí también debemos definir las reglas que describen este escenario.
knowledge2 = And(
    # TODO: Definir las condiciones que corresponden a este rompecabezas
)

# Puzzle 3: A dice "Soy un caballero" o "Soy un villano", pero no sabemos cuál.
# B dice "A dijo 'Soy un villano'". B también dice "C es un villano".
# C dice "A es un caballero".
# El conocimiento debería reflejar todas estas declaraciones contradictorias o complementarias.
knowledge3 = And(
    # TODO: Definir las condiciones que corresponden a este rompecabezas
)

# La función principal ejecutará los rompecabezas uno por uno
def main():
    # Lista de todos los símbolos involucrados en los rompecabezas.
    symbols = [AKnight, AKnave, BKnight, BKnave, CKnight, CKnave]

    # Lista de los rompecabezas con sus respectivos conocimientos.
    puzzles = [
        ("Puzzle 0", knowledge0),
        ("Puzzle 1", knowledge1),
        ("Puzzle 2", knowledge2),
        ("Puzzle 3", knowledge3)
    ]

    # Iteramos sobre cada rompecabezas y evaluamos el conocimiento asociado.
    for puzzle, knowledge in puzzles:
        print(puzzle)  # Imprimimos el nombre del rompecabezas.
        
        # Si el conocimiento está vacío (sin implementar), lo indicamos.
        if len(knowledge.conjuncts) == 0:
            print("    Not yet implemented.")
        else:
            # Si el conocimiento está implementado, verificamos cuál de los símbolos (caballeros o villanos)
            # es consistente con el conocimiento utilizando la función model_check.
            for symbol in symbols:
                if model_check(knowledge, symbol):  # Verifica si el símbolo es verdadero según el conocimiento.
                    print(f"    {symbol}")  # Imprime el símbolo si es consistente con el conocimiento.

# El bloque 'if' asegura que la función 'main' solo se ejecute cuando este script se ejecute directamente.
if __name__ == "__main__":
    main()


            </code>
        </pre>
    </section>
<section>
    <h2>Solucion Reto - Caballeros</h2>
    <p>Este ejercicio consiste en resolver acertijos lógicos de "Caballeros y Truhanes". En estos acertijos, cada personaje es un caballero (que siempre dice la verdad) o un truhán (que siempre miente). El objetivo es determinar si cada personaje es un caballero o un truhán, basado en las frases que dicen. Aquí se presentan las soluciones a los acertijos:</p>

    <article>
        <h3>Acertijo 0: Un solo personaje, A, dice "Soy tanto un caballero como un bribón".</h3>
        <p><strong>Análisis:</strong></p>
        <p>Si A es un caballero, entonces su afirmación debe ser verdadera, es decir, A debe ser tanto caballero como bribón. Pero esto es una contradicción, ya que A no puede ser ambos al mismo tiempo. Por lo tanto, A debe ser un truhán.</p>
        <p><strong>Lógica:</strong></p>
        <p>La afirmación de A es falsa, por lo que A debe ser un truhán. Si A es un truhán, su afirmación "Soy tanto un caballero como un bribón" es falsa, lo que significa que A no puede ser caballero.</p>
        <p><strong>Solución:</strong></p>
        <p>A es un truhán.</p>
    </article>

    <article>
        <h3>Acertijo 1: Dos personajes, A y B. A dice "Los dos somos truhanes", y B no dice nada.</h3>
        <p><strong>Análisis:</strong></p>
        <p>Si A es un caballero, entonces la afirmación "Los dos somos truhanes" debe ser verdadera. Esto implicaría que tanto A como B serían truhanes, lo cual es una contradicción porque A no puede ser un caballero y un truhán al mismo tiempo. Por lo tanto, A no puede ser un caballero, y debe ser un truhán. Si A es un truhán, su afirmación "Los dos somos truhanes" es falsa, lo que significa que al menos uno de los dos no puede ser un truhán. Como A ya es un truhán, entonces B debe ser un caballero.</p>
        <p><strong>Lógica:</strong></p>
        <p>A es un truhán y B es un caballero.</p>
        <p><strong>Solución:</strong></p>
        <p>A es un truhán, B es un caballero.</p>
    </article>

    <article>
        <h3>Acertijo 2: Dos personajes, A y B. A dice "Somos de la misma clase", y B dice "Somos de distinta clase".</h3>
        <p><strong>Análisis:</strong></p>
        <p>Si A es un caballero, entonces su afirmación "Somos de la misma clase" debe ser verdadera, lo que implica que A y B son del mismo tipo (ambos caballeros o ambos truhanes). Si A es un truhán, entonces su afirmación "Somos de la misma clase" es falsa, lo que implica que A y B no son del mismo tipo (uno es caballero y el otro es truhán). B dice "Somos de distinta clase". Si B es un caballero, entonces la afirmación de B debe ser verdadera, lo que implica que A y B son de distinta clase. Si B es un truhán, entonces su afirmación es falsa, lo que implica que A y B deben ser de la misma clase.</p>
        <p><strong>Posibles casos:</strong></p>
        <ul>
            <li><strong>Si A y B son caballeros:</strong> A dice la verdad, pero B también dice la verdad, lo que genera una contradicción.</li>
            <li><strong>Si A es caballero y B es truhán:</strong> A dice la verdad, pero B miente, lo que resulta en una contradicción.</li>
            <li><strong>Si A y B son truhanes:</strong> A miente, pero B también miente, lo que es consistente.</li>
        </ul>
        <p><strong>Solución:</strong></p>
        <p>A es un truhán y B es un truhán.</p>
    </article>

    <article>
        <h3>Acertijo 3: Tres personajes, A, B y C. A dice "Soy un caballero o soy un bribón", pero no sabemos cuál. B dice "A dijo 'Soy un bribón'", y "C es un bribón". C dice "A es un caballero".</h3>
        <p><strong>Análisis:</strong></p>
        <p>A dice "Soy un caballero o soy un bribón", lo cual es una afirmación verdadera, ya que A es necesariamente uno de esos dos. Si A es un caballero, entonces su afirmación es verdadera. Si A es un truhán, entonces su afirmación es falsa, lo que significa que A no puede ser ni caballero ni bribón, lo cual es una contradicción. Por lo tanto, A debe ser un caballero. B dice que A dijo "Soy un bribón". Si B es un caballero, esta afirmación debe ser verdadera, pero ya sabemos que A no es un bribón, lo que significa que B debe ser un truhán. B también dice que C es un bribón. Como B es un truhán, su afirmación es falsa, lo que significa que C no es un bribón, por lo que C debe ser un caballero. C dice "A es un caballero", lo cual es cierto si C es un caballero, por lo que C es un caballero.</p>
        <p><strong>Lógica:</strong></p>
        <p>A es un caballero, B es un truhán, C es un caballero.</p>
        <p><strong>Solución:</strong></p>
        <p>A es un caballero, B es un truhán, C es un caballero.</p>
    </article>

    <p><strong>soluciones:</strong></p>
    <ul>
        <li><strong>Acertijo 0:</strong> A es un truhán.</li>
        <li><strong>Acertijo 1:</strong> A es un truhán, B es un caballero.</li>
        <li><strong>Acertijo 2:</strong> A es un truhán, B es un truhán.</li>
        <li><strong>Acertijo 3:</strong> A es un caballero, B es un truhán, C es un caballero.</li>
    </ul>
</section>

    <section>
        <h2>Logic.py</h2>
          <p>
            El código que has proporcionado implementa una estructura de clases para trabajar con lógica proposicional, especialmente en el contexto de modelar y evaluar expresiones lógicas en un sistema de razonamiento. A continuación, te haré un resumen detallado de cada parte y de cómo funciona el código.
        </p>
        <pre>
            <code>
import itertools  # Importa la librería itertools, aunque no se está utilizando en este código

# Clase base que representa una sentencia lógica en la lógica proposicional.
class Sentence():
    # Método para evaluar la sentencia lógica en un modelo.
    def evaluate(self, model):
        """Evalúa la sentencia lógica."""  
        raise Exception("nothing to evaluate")  # Lanza una excepción si no se implementa en las subclases

    # Método que devuelve la fórmula en forma de cadena que representa la sentencia lógica.
    def formula(self):
        """Devuelve la fórmula en cadena de la sentencia lógica."""  
        return ""

    # Método que devuelve un conjunto de todos los símbolos que aparecen en la sentencia.
    def symbols(self):
        """Devuelve un conjunto de todos los símbolos en la sentencia lógica."""  
        return set()

    # Método de clase para validar que un objeto es una instancia de Sentence.
    @classmethod
    def validate(cls, sentence):
        if not isinstance(sentence, Sentence):
            raise TypeError("must be a logical sentence")  # Lanza un error si no es una instancia de Sentence

    # Método de clase que se asegura de que una expresión esté entre paréntesis si es necesario.
    @classmethod
    def parenthesize(cls, s):
        """Asegura que la expresión esté entre paréntesis si es necesario."""  
        
        # Función interna que verifica si una cadena tiene paréntesis balanceados.
        def balanced(s):
            count = 0
            for c in s:
                if c == "(":
                    count += 1
                elif c == ")":
                    if count <= 0:
                        return False
                    count -= 1
            return count == 0  # Devuelve True si los paréntesis están balanceados

        # Si la expresión ya está balanceada o es una letra, no es necesario agregar paréntesis.
        if not len(s) or s.isalpha() or (
            s[0] == "(" and s[-1] == ")" and balanced(s[1:-1])
        ):
            return s
        else:
            return f"({s})"  # Agrega paréntesis si no es una expresión simple o balanceada


# Clase que representa un símbolo en la lógica proposicional.
class Symbol(Sentence):
    def __init__(self, name):
        self.name = name  # Inicializa el símbolo con un nombre

    # Comparación entre dos objetos Symbol. Son iguales si tienen el mismo nombre.
    def __eq__(self, other):
        return isinstance(other, Symbol) and self.name == other.name

    # Método para obtener el valor hash del símbolo. Necesario para usarlo en sets y dicts.
    def __hash__(self):
        return hash(("symbol", self.name))

    # Representación del símbolo como una cadena.
    def __repr__(self):
        return self.name

    # Evalúa el símbolo en un modelo (diccionario). Devuelve True o False según el valor asignado.
    def evaluate(self, model):
        try:
            return bool(model[self.name])  # Devuelve el valor lógico del modelo para este símbolo
        except KeyError:
            raise Exception(f"variable {self.name} not in model")  # Si el símbolo no está en el modelo, lanza un error

    # Devuelve la fórmula en cadena que representa el símbolo (su nombre).
    def formula(self):
        return self.name

    # Devuelve el conjunto de símbolos involucrados, en este caso solo el símbolo mismo.
    def symbols(self):
        return {self.name}


# Clase que representa la negación de una sentencia lógica.
class Not(Sentence):
    def __init__(self, operand):
        Sentence.validate(operand)  # Valida que el operando sea una sentencia lógica
        self.operand = operand

    # Comparación entre dos objetos Not. Son iguales si tienen el mismo operando.
    def __eq__(self, other):
        return isinstance(other, Not) and self.operand == other.operand

    # Método para obtener el valor hash de la negación.
    def __hash__(self):
        return hash(("not", hash(self.operand)))

    # Representación en cadena de la negación.
    def __repr__(self):
        return f"Not({self.operand})"

    # Evalúa la negación en un modelo.
    def evaluate(self, model):
        return not self.operand.evaluate(model)

    # Devuelve la fórmula en cadena de la negación.
    def formula(self):
        return "¬" + Sentence.parenthesize(self.operand.formula())

    # Devuelve el conjunto de símbolos involucrados en la negación.
    def symbols(self):
        return self.operand.symbols()


# Clase que representa la conjunción (AND) de varias sentencias lógicas.
class And(Sentence):
    def __init__(self, *conjuncts):
        for conjunct in conjuncts:
            Sentence.validate(conjunct)  # Valida cada uno de los componentes de la conjunción
        self.conjuncts = list(conjuncts)

    # Comparación entre dos objetos And. Son iguales si tienen los mismos componentes.
    def __eq__(self, other):
        return isinstance(other, And) and self.conjuncts == other.conjuncts

    # Método para obtener el valor hash de la conjunción.
    def __hash__(self):
        return hash(
            ("and", tuple(hash(conjunct) for conjunct in self.conjuncts))
        )

    # Representación en cadena de la conjunción.
    def __repr__(self):
        conjunctions = ", ".join(
            [str(conjunct) for conjunct in self.conjuncts]
        )
        return f"And({conjunctions})"

    # Agrega un nuevo componente a la conjunción.
    def add(self, conjunct):
        Sentence.validate(conjunct)
        self.conjuncts.append(conjunct)

    # Evalúa la conjunción en un modelo (debe ser verdadera si todos los componentes son verdaderos).
    def evaluate(self, model):
        return all(conjunct.evaluate(model) for conjunct in self.conjuncts)

    # Devuelve la fórmula en cadena de la conjunción.
    def formula(self):
        if len(self.conjuncts) == 1:
            return self.conjuncts[0].formula()
        return " ∧ ".join([Sentence.parenthesize(conjunct.formula())
                           for conjunct in self.conjuncts])

    # Devuelve el conjunto de símbolos involucrados en la conjunción.
    def symbols(self):
        return set.union(*[conjunct.symbols() for conjunct in self.conjuncts])


# Clase que representa la disyunción (OR) de varias sentencias lógicas.
class Or(Sentence):
    def __init__(self, *disjuncts):
        for disjunct in disjuncts:
            Sentence.validate(disjunct)  # Valida cada uno de los componentes de la disyunción
        self.disjuncts = list(disjuncts)

    # Comparación entre dos objetos Or. Son iguales si tienen los mismos componentes.
    def __eq__(self, other):
        return isinstance(other, Or) and self.disjuncts == other.disjuncts

    # Método para obtener el valor hash de la disyunción.
    def __hash__(self):
        return hash(
            ("or", tuple(hash(disjunct) for disjunct in self.disjuncts))
        )

    # Representación en cadena de la disyunción.
    def __repr__(self):
        disjuncts = ", ".join([str(disjunct) for disjunct in self.disjuncts])
        return f"Or({disjuncts})"

    # Evalúa la disyunción en un modelo (debe ser verdadera si al menos uno de los componentes es verdadero).
    def evaluate(self, model):
        return any(disjunct.evaluate(model) for disjunct in self.disjuncts)

    # Devuelve la fórmula en cadena de la disyunción.
    def formula(self):
        if len(self.disjuncts) == 1:
            return self.disjuncts[0].formula()
        return " ∨  ".join([Sentence.parenthesize(disjunct.formula())
                            for disjunct in self.disjuncts])

    # Devuelve el conjunto de símbolos involucrados en la disyunción.
    def symbols(self):
        return set.union(*[disjunct.symbols() for disjunct in self.disjuncts])


# Clase que representa una implicación lógica (A => B).
class Implication(Sentence):
    def __init__(self, antecedent, consequent):
        Sentence.validate(antecedent)  # Valida el antecedente
        Sentence.validate(consequent)  # Valida el consecuente
        self.antecedent = antecedent
        self.consequent = consequent

    # Comparación entre dos objetos Implication. Son iguales si tienen el mismo antecedente y consecuente.
    def __eq__(self, other):
        return (isinstance(other, Implication)
                and self.antecedent == other.antecedent
                and self.consequent == other.consequent)

    # Método para obtener el valor hash de la implicación.
    def __hash__(self):
        return hash(("implies", hash(self.antecedent), hash(self.consequent)))

    # Representación en cadena de la implicación.
    def __repr__(self):
        return f"Implication({self.antecedent}, {self.consequent})"

    # Evalúa la implicación en un modelo.
    def evaluate(self, model):
        return not self.antecedent.evaluate(model) or self.consequent.evaluate(model)

    # Devuelve la fórmula en cadena de la implicación.
    def formula(self):
        return f"({self.antecedent.formula()} => {self.consequent.formula()})"

    # Devuelve el conjunto de símbolos involucrados en la implicación.
    def symbols(self):
        return self.antecedent.symbols().union(self.consequent.symbols())


# Clase que representa la bicondicionalidad lógica (A <=> B).

class Biconditional(Sentence):
    def __init__(self, left, right):
        Sentence.validate(left)
        Sentence.validate(right)
        self.left = left
        self.right = right

    def __eq__(self, other):
        return (isinstance(other, Biconditional)
                and self.left == other.left
                and self.right == other.right)

    def __hash__(self):
        return hash(("biconditional", hash(self.left), hash(self.right)))

    def __repr__(self):
        return f"Biconditional({self.left}, {self.right})"

    def evaluate(self, model):
        return ((self.left.evaluate(model)
                 and self.right.evaluate(model))
                or (not self.left.evaluate(model)
                    and not self.right.evaluate(model)))

    def formula(self):
        left = Sentence.parenthesize(str(self.left))
        right = Sentence.parenthesize(str(self.right))
        return f"{left} <=> {right}"

    def symbols(self):
        return set.union(self.left.symbols(), self.right.symbols())


def model_check(knowledge, query):
    """Checks if knowledge base entails query."""

    def check_all(knowledge, query, symbols, model):
        """Checks if knowledge base entails query, given a particular model."""

        # If model has an assignment for each symbol
        if not symbols:

            # If knowledge base is true in model, then query must also be true
            if knowledge.evaluate(model):
                return query.evaluate(model)
            return True
        else:

            # Choose one of the remaining unused symbols
            remaining = symbols.copy()
            p = remaining.pop()

            # Create a model where the symbol is true
            model_true = model.copy()
            model_true[p] = True

            # Create a model where the symbol is false
            model_false = model.copy()
            model_false[p] = False

            # Ensure entailment holds in both models
            return (check_all(knowledge, query, remaining, model_true) and
                    check_all(knowledge, query, remaining, model_false))

    # Get all symbols in both knowledge and query
    symbols = set.union(knowledge.symbols(), query.symbols())

    # Check that knowledge entails query
    return check_all(knowledge, query, symbols, dict())


            </code>
        </pre>
    </section>

</div>

</body>
</html>
